---
title: "Ok Deno, who are you?"
date: 2020-06-16 21:00:00 +0900
categories: updated
comments: true
---

Last week I posted about Node.js runtime, just to talk about this new JS runtime: Deno, an anagram of Node, which was developed by same engineer who made Node.js, Ryan Dahl. Why would you make a same thing twice? Ryan says that he wanted to fix things that he regrets nowadays. In this post, I tried to summarize changes that deno took, and compare with Node.js runtime.

![Cute deno icon](/assets/img/Deno.svg)

## First of all, pronounciation

Last year, Ryan used to cal deno _dɛnō_, but during [TSCONF 2019][link1], he mentions that most of users wants to call it as _dinō_, like dinasaur. I think both pronounciation fits well, as it is quite straight-forwardly written word.

## Why Rust and Tokio

If you remember what I've talked about [Node.js][link2], JS runtime needs 2 essentials, which is javascript engine and thread pool library. Ryan have used _libuv_ and _V8 Runtime_ to build a Node.js, but this time he has chosen different tools.

V8 Stays. Which seems quite obvious (because more and more browsers are using V8 for JS runtime), but instead of libuv (which is written in C++) he used Rust and [_Tokio_][link3] for new event pool library.

According to his speech in TSConf, this doesn't imply deno is _faster_. He even says that you can still use node.js with no problem. But him being a rumtime compiler expert, writing runtime in low-level language such as _golang_ or _rust_ was inevitable to improve performance.

To him, the one and the most biggest flaw is node modules. Dependency hell and centralized npm is not an desirable state for a web structure. Even security issues (having no authority control over resources causing unintentional leaks) were regrets that he wanted to overcome.

## Main philosophy: Deno does what OS does

![deno internal desing](/assets/img/deno-internal-design.png)

You may have seen similar diagram in node.js runtime. But there's one thing that deno has but node.js hasn't: _deno::isolate_. Basically, deno do not trust user's code, and let workers to run the _process_ to read and run the code. Why? Because OS already made an great answer to the _leveled authorization_.

If you run JS code below on deno, you'll face an error that you've never seen before.

```javascript
  const file = await Deno.open("/foo/bar.txt");
  // Do work with file
  Deno.close(file.rid);
```

```shell
Deno requests read access to "/foo/bar.txt". Grant?
[a/y/n/d (a = allow always, y = allow once, n = deny once, d = deny always)]
```

You need to grant an authorization, so the Web Worker(deno's process) can access to the file with no problem. It is a similar error from linux, when you want to access a file with different user or group.

In order to make this code work, you should grant the authorization:

```javascript
  const file = await Deno.open("/foo/bar.txt", { read: true, write: true });
  // Do work with file
  Deno.close(file.rid);
```

these examples are from [deno.land][link4]

_file.rid_ refers the process' resource id that deno has created to batch the job. If we look back the diagram above, _libdeno_ becomes a wrapper to V8 which communicate with deno::Isolate, and deno::Isolate makes a ops(which is REALLY similar how syscall works) to thread pool to handle jobs. This design philosophy from OS allows deno to be more secure and _frugal_, to handle processes.

## Typescript

Last but not least, Deno is native Typescript runtime. I might talk about whole typescript in another post, but typescript is essential to deno, as it provides _Typed array_ and _fast prototyping_.

libdeno and Ops (syscall thing I said above) communicates in Typed Array. It can be embedded as different tier application, and communicate with V8 engine with typed array. (Which in node.js was difficult, as it was extremely difficult to manipulate V8, and also insecure) Simply said, deno becomes a great wrapper made in Rust, which allows user to communicate with Typed Array.

## Conclustion: I'm still diggin' it

I watched few speeches from Ryan himself and other videos explaining about deno, and I thought this project means more to non-JS developers. Recently JS has been expanding to all around the tech field, and these rumtimes makes browsers and web environment much fertile than ever.

The point is: What web browser _cannot_ do? Ryan said he was very interested in future WebGL, and I truly believe that newer JS rumtime will allow another developers (game, software, name anything...) to do their thing on web browser. Then, what should _we_, typical front end engineer, need to study? That is a good motivation to grab a shovel and dig this massive deno's footprints.

[link1]: https://www.youtube.com/watch?v=1gIiZfSbEAE
[link2]: https://kogit.co/updated/node-threading-basics/
[link3]: https://github.com/tokio-rs/tokio
[link4]: https://deno.land/typedoc/index.html#open